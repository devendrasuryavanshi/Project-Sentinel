import crypto from "crypto";
import bcrypt from "bcryptjs";
import { Request } from "express";
import { EnvConfig } from "../config/env.config";
import { UAParser } from "ua-parser-js";

/**
 * Hash a plain text password using bcrypt.
 */
export const hashPassword = async (password: string): Promise<string> => {
  return bcrypt.hash(password, EnvConfig.SALT);
};

/**
 * Compare a plain text password with a hash.
 */
export const comparePassword = async (
  password: string,
  hash: string
): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};

/**
 * Generate a stable SHA-256 device fingerprint from a request object.
 *
 * The fingerprint source components (in order) are:
 *  - browser name (from user-agent)
 *  - OS name (from user-agent)
 *  - raw user-agent (for extra entropy)
 *  - accept-language
 *  - accept-encoding
 *  - viewport-width (if present)
 *  - time-zone / timezone / x-timezone (if present)
 *  - x-forwarded-for (if present)
 *
 * All values are normalized (trim + collapse whitespace) and concatenated with
 * a pipe separator before hashing.
 *
 * @param request - Incoming HTTP request
 * @returns hex-encoded SHA-256 fingerprint string
 */
export const generateDeviceFingerprint = (request: Request): string => {
  const headers = request?.headers ?? {};

  // Primary: user-agent
  const uaRaw = (getHeader(headers, "user-agent") || "").toString();

  // Parse UA for browser and os (falls back to empty strings if parsing fails)
  const parsedHeaders = new UAParser(uaRaw);
  const browserName = (parsedHeaders?.getBrowser?.().name || "").toString();
  const osName = (parsedHeaders?.getOS?.().name || "").toString();

  const acceptLanguage = getHeader(headers, "accept-language") || "";
  const acceptEncoding = getHeader(headers, "accept-encoding") || "";
  const viewportWidth =
    getHeader(headers, "viewport-width") ||
    getHeader(headers, "sec-ch-viewport-width") ||
    "";
  const timeZone =
    getHeader(headers, "time-zone") ||
    getHeader(headers, "timezone") ||
    getHeader(headers, "x-time-zone") ||
    getHeader(headers, "x-timezone") ||
    "";
  const xForwardedFor = getHeader(headers, "x-forwarded-for") || "";

  const normalize = (v: string) => v.replace(/\s+/g, " ").trim();

  const parts = [
    browserName,
    osName,
    uaRaw,
    acceptLanguage,
    acceptEncoding,
    viewportWidth,
    timeZone,
    xForwardedFor,
  ]
    .map(normalize)
    .filter(Boolean);

  const source = parts.join("|");

  return crypto.createHash("sha256").update(source).digest("hex");
};

export const getHeader = (headers: any, name: string): string => {
  if (!headers) return "";
  if (typeof headers.get === "function") return headers.get(name) || "";
  return headers[name.toLowerCase()] || headers[name] || "";
};

/**
 * Generate a random hex string (used for Refresh Tokens).
 */
export const generateRandomToken = (length = 32): string => {
  return crypto.randomBytes(length).toString("hex");
};

/**
 * Create a SHA256 hash of a token (for database storage).
 */
export const hashToken = (token: string): string => {
  return crypto.createHash("sha256").update(token).digest("hex");
};

/**
 * Generate a numeric One Time Password (OTP).
 */
export const generateNumericOtp = (length: number = 6): string => {
  const min = Math.pow(10, length - 1);
  const max = Math.pow(10, length) - 1;
  return crypto.randomInt(min, max).toString();
};

/**
 * Hash a One-Time Password (OTP) using SHA256.
 * @param {string} otp - One-Time Password to hash.
 * @returns {string} SHA256 hash of the OTP.
 */
export const hashOTP = (otp: string): string => {
  return crypto.createHash("sha256").update(otp).digest("hex");
};

/*************  ✨ Windsurf Command ⭐  *************/
/**
 * Generates a SHA256 fingerprint using both the client fingerprint and device fingerprint.
 * 
 * This fingerprint is used to identify a client-device pair, and is used to store
 * information related to the pair in the database.
 * 
 * @param clientFingerprint - Client fingerprint (generated by fingerprint middleware)
 * @param deviceFingerprint - Device fingerprint (generated from the request object)
 * @returns SHA256 fingerprint string
 */
/*******  6c70253a-a6f2-44a8-b952-6a29a4949472  *******/
export const generateFingerprintUsingClientAndDeviceFingerprints = (
  clientFingerprint: string,
  deviceFingerprint: string
): string => {
  return crypto
    .createHash("sha256")
    .update(clientFingerprint + deviceFingerprint)
    .digest("hex");
};
